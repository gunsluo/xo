// Package models contains the types for schema.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"fmt"
)

// BookFilter related to BookQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type BookFilter struct {
	Conjunction *string // enum in "AND", "OR", nil(consider as single condition)
	Isbn        *string `json:"isbn"`         // equal to Isbn
	IsbnLike    *string `json:"isbn_like"`    // LIKE
	IsbnILike   *string `json:"isbn_ilike"`   // ILIKE case-insensitive
	IsbnNLike   *string `json:"isbn_nlike"`   // NOT LIKE
	IsbnNILike  *string `json:"isbn_nilike"`  // NOT ILIKE case-insensitive
	Title       *string `json:"title"`        // equal to Title
	TitleLike   *string `json:"title_like"`   // LIKE
	TitleILike  *string `json:"title_ilike"`  // ILIKE case-insensitive
	TitleNLike  *string `json:"title_nlike"`  // NOT LIKE
	TitleNILike *string `json:"title_nilike"` // NOT ILIKE case-insensitive
	Year        *string `json:"year"`         // equal to Year
	YearLt      *string `json:"year_lt"`      // less than Year
	YearLte     *string `json:"year_lte"`     // less than and equal to Year
	YearGt      *string `json:"year_gt"`      // greater than Year
	YearGte     *string `json:"year_gte"`     // greater than and equal to Year
}

// BookQueryArguments composed by Cursor, BookFilter and sql filter string
type BookQueryArguments struct {
	Cursor
	Where *BookFilter

	// non-export field
	filterArgs *filterArguments
}

// getBookFilter return the sql filter
func getBookFilter(filter *BookFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Isbn != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "isbn", option: "=", value: *filter.Isbn})
	}
	if filter.IsbnLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "isbn", option: "LIKE", value: *filter.IsbnLike})
	}
	if filter.IsbnILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "isbn", option: "ILIKE", value: *filter.IsbnILike})
	}
	if filter.IsbnNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "isbn", option: "NOT LIKE", value: *filter.IsbnNLike})
	}
	if filter.IsbnNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "isbn", option: "NOT ILIKE", value: *filter.IsbnNILike})
	}
	if filter.Title != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "title", option: "=", value: *filter.Title})
	}
	if filter.TitleLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "title", option: "LIKE", value: *filter.TitleLike})
	}
	if filter.TitleILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "title", option: "ILIKE", value: *filter.TitleILike})
	}
	if filter.TitleNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "title", option: "NOT LIKE", value: *filter.TitleNLike})
	}
	if filter.TitleNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "title", option: "NOT ILIKE", value: *filter.TitleNILike})
	}
	if filter.Year != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "year", option: "=", value: *filter.Year})
	}
	if filter.YearLt != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "year", option: "<", value: *filter.YearLt})
	} else if filter.YearLte != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "year", option: "<=", value: *filter.YearLte})
	}
	if filter.YearGt != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "year", option: ">", value: *filter.YearGt})
	} else if filter.YearGte != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "year", option: ">=", value: *filter.YearGte})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyBookQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyBookQueryArgsDefaults(queryArgs *BookQueryArguments) *BookQueryArguments {
	if queryArgs == nil {
		queryArgs = &BookQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// extension block
