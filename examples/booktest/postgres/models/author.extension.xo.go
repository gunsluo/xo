// Package models contains the types for schema.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"fmt"
)

// AuthorFilter related to AuthorQueryArguments
// struct field name contain table column name in Camel style and logic operator(lt, gt etc)
// only indexed column and special column defined in ExtraFilters declared in file extra_rules.yaml
type AuthorFilter struct {
	Conjunction *string // enum in "AND", "OR", nil(consider as single condition)
	Name        *string `json:"name"`        // equal to Name
	NameLike    *string `json:"name_like"`   // LIKE
	NameILike   *string `json:"name_ilike"`  // ILIKE case-insensitive
	NameNLike   *string `json:"name_nlike"`  // NOT LIKE
	NameNILike  *string `json:"name_nilike"` // NOT ILIKE case-insensitive
}

// AuthorQueryArguments composed by Cursor, AuthorFilter and sql filter string
type AuthorQueryArguments struct {
	Cursor
	Where *AuthorFilter

	// non-export field
	filterArgs *filterArguments
}

// getAuthorFilter return the sql filter
func getAuthorFilter(filter *AuthorFilter) (*filterArguments, error) {
	if filter == nil {
		return nil, nil
	}
	conjunction := ""
	conjCnt := 0
	var filterPairs []*filterPair
	if filter.Conjunction != nil {
		conjunction = *filter.Conjunction
		if _, ok := sqlConjunctionMap[conjunction]; !ok {
			return nil, fmt.Errorf("unsupported conjunction:%v", filter.Conjunction)
		}
	}
	if filter.Name != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "name", option: "=", value: *filter.Name})
	}
	if filter.NameLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "name", option: "LIKE", value: *filter.NameLike})
	}
	if filter.NameILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "name", option: "ILIKE", value: *filter.NameILike})
	}
	if filter.NameNLike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "name", option: "NOT LIKE", value: *filter.NameNLike})
	}
	if filter.NameNILike != nil {
		conjCnt++
		filterPairs = append(filterPairs, &filterPair{fieldName: "name", option: "NOT ILIKE", value: *filter.NameNILike})
	}
	if conjCnt == 0 {
		return nil, nil
	}
	if len(conjunction) > 0 && conjCnt < 2 {
		return nil, fmt.Errorf("invalid filter conjunction: %v need more than 2 parameter but have: %v", *filter.Conjunction, conjCnt)
	}
	if len(conjunction) == 0 && conjCnt != 1 {
		return nil, fmt.Errorf("multi field:%v should be connected by conjunction AND or OR", conjCnt)
	}
	filterArgs := &filterArguments{filterPairs: filterPairs, conjunction: conjunction, conjCnt: conjCnt}
	return filterArgs, nil
}

// ApplyAuthorQueryArgsDefaults assigns default cursor values to non-nil fields.
func ApplyAuthorQueryArgsDefaults(queryArgs *AuthorQueryArguments) *AuthorQueryArguments {
	if queryArgs == nil {
		queryArgs = &AuthorQueryArguments{
			Cursor: DefaultCursor,
		}
		return queryArgs
	}
	if queryArgs.Offset == nil {
		queryArgs.Offset = DefaultCursor.Offset
	}
	if queryArgs.Limit == nil {
		queryArgs.Limit = DefaultCursor.Limit
	}
	if queryArgs.OrderBy == nil {
		queryArgs.OrderBy = DefaultCursor.OrderBy
	}
	if queryArgs.Desc == nil {
		queryArgs.Desc = DefaultCursor.Desc
	}
	if queryArgs.Dead == nil {
		queryArgs.Dead = DefaultCursor.Dead
	}
	if queryArgs.After == nil {
		queryArgs.After = DefaultCursor.After
	}
	if queryArgs.First == nil {
		queryArgs.First = DefaultCursor.First
	}
	if queryArgs.Before == nil {
		queryArgs.Before = DefaultCursor.Before
	}
	if queryArgs.Last == nil {
		queryArgs.Last = DefaultCursor.Last
	}
	return queryArgs
}

// extension block
